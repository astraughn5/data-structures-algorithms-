const edges = [
	['w', 'x'],
	['x', 'y'],
	['z', 'y'],
	['z', 'v'],
	['w', 'v']
 ]
 //return the shortest path where the weight is the # of edges --> BFS, queues (FIFO)
 //have main function that takes in the edges, src, dst
 //have a helper function to convert edges to adjacency list
 
 function shortestPath(edges, src, dest){
   const graph = convertToAdjList(edges)
   let queue = [ [src, 0] ]
   const visited = new Set([src])
 
   while (queue.length > 0){
	 const [ node, distance ] = queue.shift()
	 if (node === dest){
	   return distance
	 }
	 for (let neighbor of graph[node]){
	   if (!visited.has(neighbor)){
		 visited.add(neighbor)
		 queue.push([ neighbor, distance + 1])
	   }
	 }    
   }
   return -1
 }
 
 function convertToAdjList(edges){
   const graph = {}
   for (let edge of edges){
	 const [ a, b ] = edge
	 if (!(a in graph)){
	   graph[a] = []
	 }
	 if (!(b in graph)){
	   graph[b] = []
	 }
 
	graph[a].push(b)
	graph[b].push(a)
   }
   return graph
 }
 
console.log(shortestPath(edges, 'w', 'x'))
   

// const graph = {
// 	a: ['b', 'c'],
// 	b: ['d'],
// 	c: ['e'],
// 	d: ['f'],
// 	e: [],
// 	f: [],
// 	}
	//establish a result and a stack
	// loop while stack is not empy and add to result
	
	function depthFirstSearch(graph, source){
	  let result = []
	  let stack = [source]
	  while (stack.length > 0){
		const current = stack.pop()
		result.push(current)
	
		for (let neighbor of graph[current]){
		   stack.push(neighbor)
		}
	  }
	  
	  return result
	}

	//console.log(depthFirstSearch(graph, 'a'))
	
	function bfs(graph, source){
	  let result = []
	  let queue = [source]
	
	  while (queue.length > 0){
		const current = queue.shift()
		result.push(current)
	
		for (let neighbor of graph[current]){
		  queue.push(neighbor)
		}
	  }
	  return result
	}
	
//console.log(bfs(graph, 'a'))



/*
function dfsPrint(graph, source){ //this is only for directed graphs, undirected will be endless loop
	let result = []
	const stack = [source]
	while(stack.length > 0){
		const current = stack.pop()
		result.push(current)
		//console.log(current)
		console.log(graph)
		//console.log(graph.adjacentList[current])
		for (let neighbor of graph[current]){
			stack.push(neighbor)
		}
	}
	return result
}

function bfsPrint(graph, source){ //only for directed graphs
	const queue = [source]
	let result = []
	while (queue.length > 0){
		const current = queue.shift()
		result.push(current)
		for (let neighbor of graph[current]){
			queue.push(neighbor)
		}
	}
}
*/